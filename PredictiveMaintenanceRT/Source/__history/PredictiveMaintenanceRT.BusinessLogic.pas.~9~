unit PredictiveMaintenanceRT.BusinessLogic;

interface

uses
  PredictiveMaintenanceRT.BusinessLogicInterface, PredictiveMaintenanceRT.PredictiveAlgorithm, 
  PredictiveMaintenanceRT.CellDataModel, PredictiveMaintenanceRT.QueryExecutor,
  PredictiveMaintenanceRT.PartialModel, Data.DB, System.Generics.Collections,
  FireDAC.Comp.Client;

type
  TPredictiveMaintenance = class(TInterfacedObject, IPredictiveMaintenance)

  private
    {Private declarations}
    FPredictiveAlgorithm: TPredictiveAlgorithm;
    FQueryExecutor: TQueryExecutor;

    function GetPredictiveAlgorithm: TPredictiveAlgorithm;
    property PredictiveAlgorithm: TPredictiveAlgorithm read GetPredictiveAlgorithm write FPredictiveAlgorithm;
    
    function GetQueryExecutor: TQueryExecutor;
    property QueryExecutor: TQueryExecutor read GetQueryExecutor write FQueryExecutor;

    
    function GetCellModel(ACellId: integer): TCellDataModel;
    function PopulateCellModel(ACell: TCellDataModel): TCellDataModel;
    function DataSetToList(ADataSet: TFDQuery): TList<TPartialModel>;
  public
    {Public declarations}
    function GetMaintenanceDate(ACellId: integer): Extended;

  end;

implementation

{ TPredictiveMaintenance }
uses
  PredictiveMaintenanceRT.Constants, System.SysUtils;

function TPredictiveMaintenance.GetMaintenanceDate(ACellId: integer): Extended;
begin
  Result := PredictiveAlgorithm.CalculateMaintenanceDate(GetCellModel(ACellId));
end;

function TPredictiveMaintenance.GetPredictiveAlgorithm: TPredictiveAlgorithm;
begin
  if not Assigned(FPredictiveAlgorithm) then
    FPredictiveAlgorithm := TPredictiveAlgorithm.Create;
  Result := FPredictiveAlgorithm;
end;

 function TPredictiveMaintenance.GetQueryExecutor: TQueryExecutor;
begin
  if not Assigned(FQueryExecutor) then
    FQueryExecutor := TQueryExecutor.Create(DB_NAME, SERVER_NAME, DEFAULT_USERNAME, DEFAULT_PASSWORD);
  Result := FQueryExecutor;
end;

function TPredictiveMaintenance.PopulateCellModel(ACell: TCellDataModel): TCellDataModel;
var
  LData: TFDQuery;
begin
  try
    LData := QueryExecutor.ExecuteQuery(Format(QUERY_PARTIALS, [intToStr(ACell.CellId)]));
    if LData <> nil then
      ACell.Partials := DataSetToList(LData)
    else
      raise Exception.Create('SQL Data Not Found');
    Result := ACell;
  finally
    LData.Free;
  end;

end;

function TPredictiveMaintenance.DataSetToList(
  ADataSet: TFDQuery): TList<TPartialModel>;
var
  LPartials: TList<TPartialModel>;
  LPartial: TPartialModel;
begin
  LPartials := TList<TPartialModel>.Create;
  try
    ADataSet.Open;
    if not ADataSet.Active then
      raise Exception.Create('Dataset is not open.');
    ADataSet.First;
    while not ADataSet.Eof do
    begin
      LPartial.PartialId := ADataSet.FieldByName('ID').AsInteger;
      LPartial.CellId := ADataSet.FieldByName('IDCelPro').AsInteger;
      LPartial.StartTime := ADataSet.FieldByName('Inizio').AsFloat;
      LPartial.WorkHours := ADataSet.FieldByName('TempoLavoroInOre').AsFloat;
      LPartial.EndTime := ADataSet.FieldByName('Fine').AsFloat;
      LPartial.Quantity := ADataSet.FieldByName('QtOut').AsFloat;
      LPartials.Add(LPartial);
      ADataSet.Next;
    end;
    Result := LPartials;
  finally
    LPartials.Free;
  end;
end;

function TPredictiveMaintenance.GetCellModel(
  ACellId: integer): TCellDataModel;
var
  LCellModel: TCellDataModel;
begin
  LCellModel := TCellDataModel.Create;
  LCellModel.CellId := ACellId;
  LCellModel.ThresholdPieces := 5000;
  //funzione che popola i dati del modello tramite querySQL
  LCellModel := PopulateCellModel(LCellModel);
  Result := LCellModel;
end;

end.
