unit PredictiveMaintenanceRT.PredictiveAlgorithm;

interface

uses
  PredictiveMaintenanceRT.CellDataModel;

type
  TPredictiveAlgorithm = class

  private
    {Private declarations}
    FCellDataModel: TCellDataModel;

    function GetCellDataModel: TCellDataModel;
    property CellDataModel: TCellDataModel read GetCellDataModel write FCellDataModel;

    function CalculateMaintenanceDate: Extended;
    function WorkTimeToDays(AHours: Extended): Extended;

    function PiecesHour(APieces, AHours: Extended): Extended;
    function PiecesDay(Apieces: Extended): Extended;
    function DaysForPieces(APieces, APiecesADay: Extended): Extended;

  public
    {Public declarations}
  end;

implementation

uses
  PredictiveMaintenanceRT.Constants, PredictiveMaintenanceRT.Messages;

{ TPredictiveAlgorithm }

function TPredictiveAlgorithm.CalculateMaintenanceDate: Extended;
var
  tmp : Extended;
  LCell: TCellDataModel;
begin

  //convertire FWorkTimeToNextMaintenance in giorni di lavoro calcolando che la macchina lavorerà teoricamente
  //8 ore al giorno e solo 5 giorni alla settimana quindi fare un calcolo che ritorna una data nel futuro


  //prendere in considerazione solo i tempi di lavoro per calcolare la data in base alla soglia tramite tempo di lavoro+

  //prendere in considerazione solo i pezzi prodotti per calcolare la data in base alla soglia tramite i pezzi prodotti


  //se so che la soglia è di 100 pezzi e ne ho già prodotti 30 fino ad adesso la data sarà:
  //data di oggi + giorni che servono per produrre altri 70 pezzi

  //per calcolare i giorni che servono per produrre x pezzi dovro sapere quanti pezzi penso di produrre in un giorno
  //potrei prendere questa informazione dai record passati

  //per sapere i giorni di lavoro è meglio passare dicendo quanti pezzi produco in un ora di lavoro

  //calcolare quanti pezzi produco all ora in media:
  //pezzi prodotti / ore di lavoro per produrre quei pezzi := pezzi prodotti in un ora
  //questi dati vengono presi dall ultimo parziale, si potrebbe prendere facendo una media degli ultimi x parziali(in un secondo momento)
  tmp := PiecesHour(70, 50);

  //trovare a questo punto i pezzi prodotti in una giornata di lavoro:
  //pezzi prodotti in un ora * 8 := pezzi prodotti in un giorno(8 ore)
  tmp := PiecesDay(tmp);

  //trovare i giorni che servono per produrre x pezzi:
  //x pezzi da produrre / pezzi prodotti in un giorno := giorni per produrre x pezzi
  tmp := DaysForPieces(70, tmp);

  Result := DATE_INT + tmp;

  //bisogna tenere in considerazione i giorni non lavorativi
  //(forse prendendo in considerazione le settimane piuttosto che i giorni)



  //prendere in considerazione solo la data dall ultima manutenzione fino ad oggi per calcolare
  //la data in base alla soglia di tempo generale


end;

function TPredictiveAlgorithm.DaysForPieces(APieces,
  APiecesADay: Extended): Extended;
begin
  Result := APieces / APiecesADay;
end;

function TPredictiveAlgorithm.PiecesDay(Apieces: Extended): Extended;
begin
  Result := Apieces * WORK_HOURS_IN_A_DAY;
end;

function TPredictiveAlgorithm.PiecesHour(APieces, AHours: Extended): Extended;
begin
  Result := APieces / AHours;
end;

function TPredictiveAlgorithm.WorkTimeToDays(AHours: Extended): Extended;
begin
  Result := AHours / WORK_HOURS_IN_A_DAY;
end;

function TPredictiveAlgorithm.GetCellDataModel: TCellDataModel;
begin
  if not Assigned(FCellDataModel) then
    FCellDataModel := TCellDataModel.Create;
  Result:= FCellDataModel;
end;

end.
